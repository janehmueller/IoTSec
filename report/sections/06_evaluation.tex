\section{Evaluation}
\label{section:evaluation}

%\begin{enumerate}
%	\item Evaluierung interessanter Aspekte anhand von Statistiken
%\end{enumerate}

When performing fully automated fuzzing, processing of one fuzzed message takes around 5.2 seconds. Setup times for the devices can vary due to cached binaries but can reach the magnitude of several minutes. In order to evaluate the fuzzer and the system under test, we performed 20.000 fuzzing requests but did not succeeded in causing a crash or a device malfunction. Nonetheless, we ensured that potential crashes can be found by our setup, by intentionally adding an infinite loop to the CoAP implementation of Contiki-NG as a reaction to a specific message.

\scapy turned out to be easily usable in order to automatically construct CoAP messages. Even though a random fuzz method is also available in \scapy, we decided to fuzz the message fields by ourselves. This enables us to perform informed random and generational fuzzing. Unfortunately, \scapy does not implement further CoAP extension RFCs. Such RFCs are the observation of CoAP resources proposed in RFC7641\footnote{\url{https://tools.ietf.org/html/rfc7641}} and block-wise transfers of larger messages proposed in RFC7959\footnote{\url{https://tools.ietf.org/html/rfc7959}}. Since the system under test does implement these RFCs, this would be a starting point for further research and could be done by either extending the \scapy CoAP contribution or the fuzzer itself. This also leads to upper bounds with respect to the message size, because CoAP messages should not exceed an IPv6 MTU in order to avoid fragmentation.
