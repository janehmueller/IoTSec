\section{Evaluation}

\begin{enumerate}
	\item Evaluierung interessanter Aspekte anhand von Statistiken
\end{enumerate}

When performing fully automated fuzzing, processing of one fuzzed message takes around 5.2 seconds. Setup times for the devices can vary due to cached binaries but can reach the magnitude of several minutes. In order to evaluate the fuzzer and the system under test, we performed 20.000 runs but did not succeeded to trigger a crash. Nonetheless we ensured that potential crashes can be found by our setup by intentionally adding an infinite loop to the CoAP server implementation as reaction to a specific message.  

The scapy tool turned out to be easily usable in order to automatically construct CoAP messages. Even though a random fuzz method is also available in scapy, we decided to fuzz the message fields by ourselves in order to perform informed random or generational fuzzing. Unfortunately, scapy doesn't implement further very common CoAP RFCs. So the observation of CoAP resources like proposed in RFC7641 and the block-wise transfer of larger messages as proposed in RFC7959 is not implemented. Since the system under test does implement these RFCs, this would be a starting point for further research and could be done by either augmenting the scapy CoAP contribution or the fuzzer itself. This also leads to upper bounds with respect to the message size, because CoAP messages should not exceed a IPv6 MTU in order to avoid fragmentation. 

